/**
 * Scheduled task for sending daily/weekly digest emails
 * This can be run as a Cloudflare Cron Trigger or manually via API
 */

interface Env {
  DATA_BUCKET: R2Bucket
  RESEND_API_KEY?: string  // For email delivery
  ADMIN_EMAIL?: string
}

// Data file paths in R2
const PATHS = {
  emails: 'data/email-subscriptions.json',
  features: 'data/feature-requests.json',
  feedback: 'data/feedback.json',
  lastDigest: 'data/last-digest.json',
}

interface DigestState {
  lastSentAt: string
  lastEmailCount: number
  lastFeatureCount: number
  lastFeedbackCount: number
}

// Read JSON from R2
async function readData<T>(bucket: R2Bucket, path: string): Promise<T | null> {
  const object = await bucket.get(path)
  if (!object) return null
  const text = await object.text()
  try {
    return JSON.parse(text)
  } catch {
    return null
  }
}

// Write JSON to R2
async function writeData<T>(bucket: R2Bucket, path: string, data: T): Promise<void> {
  await bucket.put(path, JSON.stringify(data, null, 2), {
    httpMetadata: { contentType: 'application/json' },
  })
}

// Generate digest HTML
function generateDigestHtml(stats: {
  newEmails: number
  newFeatures: number
  newFeedback: number
  topFeatures: [string, number][]
  recentFeedback: { type: string; message: string; submittedAt: string }[]
}): string {
  return `
<!DOCTYPE html>
<html>
<head>
  <style>
    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; line-height: 1.6; color: #333; max-width: 600px; margin: 0 auto; padding: 20px; }
    h1 { color: #b8860b; border-bottom: 2px solid #b8860b; padding-bottom: 10px; }
    h2 { color: #666; margin-top: 30px; }
    .stat { background: #f5f5f5; padding: 15px; margin: 10px 0; border-left: 4px solid #b8860b; }
    .stat-number { font-size: 24px; font-weight: bold; color: #b8860b; }
    .feature-item { display: flex; justify-content: space-between; padding: 8px 0; border-bottom: 1px solid #eee; }
    .feedback-item { background: #f9f9f9; padding: 10px; margin: 10px 0; border-radius: 4px; }
    .feedback-type { display: inline-block; padding: 2px 8px; border-radius: 4px; font-size: 12px; text-transform: uppercase; }
    .feedback-type.bug { background: #ffebee; color: #c62828; }
    .feedback-type.suggestion { background: #e3f2fd; color: #1565c0; }
    .feedback-type.praise { background: #e8f5e9; color: #2e7d32; }
    .feedback-type.general { background: #f5f5f5; color: #666; }
    .date { color: #999; font-size: 12px; }
    footer { margin-top: 40px; padding-top: 20px; border-top: 1px solid #eee; color: #999; font-size: 12px; }
  </style>
</head>
<body>
  <h1>‚óÜ rawctl Daily Digest</h1>
  <p>Here's what's new from your landing page:</p>

  <h2>üìä New Submissions</h2>
  <div class="stat">
    <span class="stat-number">${stats.newEmails}</span> new email subscribers
  </div>
  <div class="stat">
    <span class="stat-number">${stats.newFeatures}</span> feature request submissions
  </div>
  <div class="stat">
    <span class="stat-number">${stats.newFeedback}</span> feedback messages
  </div>

  ${stats.topFeatures.length > 0 ? `
  <h2>üèÜ Top Requested Features</h2>
  <div>
    ${stats.topFeatures.map(([feature, votes]) => `
      <div class="feature-item">
        <span>${feature}</span>
        <span>${votes} votes</span>
      </div>
    `).join('')}
  </div>
  ` : ''}

  ${stats.recentFeedback.length > 0 ? `
  <h2>üí¨ Recent Feedback</h2>
  ${stats.recentFeedback.map(fb => `
    <div class="feedback-item">
      <span class="feedback-type ${fb.type}">${fb.type}</span>
      <p>${fb.message}</p>
      <span class="date">${new Date(fb.submittedAt).toLocaleDateString()}</span>
    </div>
  `).join('')}
  ` : ''}

  <footer>
    <p>This digest was automatically generated by the rawctl data collection system.</p>
    <p>View all data at: <a href="https://api.rawctl.app/api/stats">API Stats</a></p>
  </footer>
</body>
</html>
  `.trim()
}

// Send email via Resend API
async function sendEmail(apiKey: string, to: string, subject: string, html: string): Promise<boolean> {
  try {
    const response = await fetch('https://api.resend.com/emails', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${apiKey}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        from: 'rawctl <digest@rawctl.app>',
        to: [to],
        subject,
        html,
      }),
    })
    return response.ok
  } catch (error) {
    console.error('Failed to send email:', error)
    return false
  }
}

// Main scheduled handler
export async function handleScheduled(env: Env): Promise<Response> {
  // Read current state
  const lastDigest = await readData<DigestState>(env.DATA_BUCKET, PATHS.lastDigest) || {
    lastSentAt: new Date(0).toISOString(),
    lastEmailCount: 0,
    lastFeatureCount: 0,
    lastFeedbackCount: 0,
  }

  // Read all data
  const emails = await readData<any[]>(env.DATA_BUCKET, PATHS.emails) || []
  const features = await readData<any[]>(env.DATA_BUCKET, PATHS.features) || []
  const feedbacks = await readData<any[]>(env.DATA_BUCKET, PATHS.feedback) || []

  // Calculate new items since last digest
  const newEmails = emails.length - lastDigest.lastEmailCount
  const newFeatures = features.length - lastDigest.lastFeatureCount
  const newFeedback = feedbacks.length - lastDigest.lastFeedbackCount

  // Skip if nothing new
  if (newEmails === 0 && newFeatures === 0 && newFeedback === 0) {
    return Response.json({ message: 'No new data to report' })
  }

  // Aggregate feature votes
  const featureVotes: Record<string, number> = {}
  for (const req of features) {
    for (const feature of req.features || []) {
      featureVotes[feature] = (featureVotes[feature] || 0) + 1
    }
  }
  const topFeatures = Object.entries(featureVotes)
    .sort((a, b) => b[1] - a[1])
    .slice(0, 5)

  // Get recent feedback (last 5)
  const recentFeedback = feedbacks
    .slice(-5)
    .reverse()
    .map(f => ({
      type: f.type || 'general',
      message: f.message?.substring(0, 200) + (f.message?.length > 200 ? '...' : ''),
      submittedAt: f.submittedAt,
    }))

  // Generate digest
  const html = generateDigestHtml({
    newEmails,
    newFeatures,
    newFeedback,
    topFeatures,
    recentFeedback,
  })

  // Send email if configured
  let emailSent = false
  if (env.RESEND_API_KEY && env.ADMIN_EMAIL) {
    emailSent = await sendEmail(
      env.RESEND_API_KEY,
      env.ADMIN_EMAIL,
      `rawctl Digest: ${newEmails + newFeatures + newFeedback} new submissions`,
      html
    )
  }

  // Update last digest state
  const newState: DigestState = {
    lastSentAt: new Date().toISOString(),
    lastEmailCount: emails.length,
    lastFeatureCount: features.length,
    lastFeedbackCount: feedbacks.length,
  }
  await writeData(env.DATA_BUCKET, PATHS.lastDigest, newState)

  return Response.json({
    success: true,
    emailSent,
    stats: { newEmails, newFeatures, newFeedback, topFeatures },
    html, // Include HTML for manual viewing
  })
}

// Export for Cloudflare Cron Trigger
export default {
  async scheduled(event: ScheduledEvent, env: Env, ctx: ExecutionContext) {
    ctx.waitUntil(handleScheduled(env))
  },

  // Also expose as HTTP endpoint for manual trigger
  async fetch(request: Request, env: Env): Promise<Response> {
    const url = new URL(request.url)
    if (url.pathname === '/trigger-digest') {
      return handleScheduled(env)
    }
    return Response.json({ error: 'Not found' }, { status: 404 })
  },
}
